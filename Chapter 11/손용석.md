# 11. 합성과 유연한 설계

책을 읽기 전 목차를 보면서 드는 궁금한 점

1. 상속과 합성의 차이는 무엇인가?
2. 상속으로 인한 조합의 폭발적인 증가는 어떠한 효용이 있는가?
    1. 좋다면, 왜 합성으로 변경하는가?
3. 합성으로 인한 설계적 이점은 무엇이 되는가?

---

1. 상속 관계 : is-a
    1. 상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야한다 → 결합도가 높아지는 원인
    2. 재사용 관점에서는 쉽고 간단하지만, 우아한 방법은 아니다.
    3. 화이트박스 재사용
    4. 의존성 : 컴파일 단계에서 결정
2. 합성 관계: has-a
    1. 구현에 의존하지 않는다.
    2. 퍼블릭 인터페이스에 의존하기에, 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있다.
        1. 변경에 더 안정적인 코드를 얻을 수 있다.
    3. 블랙박스 재사용
    4. 의존성 : 런타임에 해결

Me) 일반적인 MVC 모델은 합성관계에 의한 설계가 아닐까….?

# 상속을 합성으로 변경하기

포워딩 메서드 : 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결함 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법이다.

## 몽키패치

현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것을 가르킨다.

Java : 언어 차원에서는 몽키패치를 지원하지 않기때문에 바이트코드를 직접 변환하거나 AOP를 이용해 몽키패치를 구현하고 있다.

Python

```java
import pandas as pd

def word_counter(self):
    """This method will return all the words inside the column that has the word 'tom'"""
    return [i for i in self.columns if "tom" in i]

pd.DataFrame.word_counter_patch = word_counter  # monkey-patch the DataFrame class
df = pd.DataFrame([list(range(4))], columns=["Arm", "tomorrow", "phantom", "tommy"])
print(df.word_counter_patch())
```

- pd.DataFrame.word_counter_patch 에다가 직접 정의한 word_counter 로 변경을 하였다.
    - 실제 코드에는 영향이 없으며, 해당 코드를 수행하는 파일에만 영향을 미침.

어원 : 게릴라 패치 → 발음이 비슷한 고릴라 패치 → 고릴라는 너무 큰 느낌이라서 작은 영장류인 몽키로 이름 변경

# 상속으로 인한 조합의 폭발적인 증가

- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

Me) 아.. 중복된 코드가 많이 나온다는 것을 폭발적인 증가라고 표현을 했구나 !

망할 코드 설계가 나온 케이스를 의미한다.

# 합성 관계로 변경하기

합성을 사용하면 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다.

- 상속이 조합의 결과를 **개별 클래스 안**으로 밀어넣는 방법
- 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 **실행 시점에 인스턴스를 조립**하는 방법

```java
public class Phone {
	private RatePolicy ratePolicy;
	private List<Call> calls = new ArrayList<>();

	public Phone(RatePolicy ratePolciy) {
		this.ratePolicy = ratePolicy;
	}

	public List<Call> getCalls() {
		return Collections.unmodifiableList(calls);
	}

	public Money calculateFee() {
		return ratePolicy.calculateFee(this);
	}
}
```

Phone 내부에 RatePolicy에 대한 참조자가 포함되어 있다.

→ 합성을 의미한다.

 다양한 ReatePolicy와 협력을 해야한다

→ 인터페이스로 정의가 되어있으며, 런타임 의존성으로 대체를 한다. 그리고 의존성을 주입받는다.

두가지 제약에 따라 부가 정책을 구현해야한다.

1. 부가 정책은 기본 정책이나 다른 부가 정책의 인스턴스를 참조할 수 있어야 한다.
    1. 부가 정책의 인스턴스는 어떤 종류의 정책과도 합성될 수 있어야한다.
2. Phone 입장에서는 자신이 기본 정책의 인스턴스에게 메시지를 전송하고 있는지, 부가 정책의 인스턴스에게 메시지를 전송하고 있는지를 몰라야한다.
    1. 기본 정책과 부가 정책은 협력 안에서 동일한 ‘역할’을 수행해야한다.
    2. 부가 정책이 기본 정책과 동일한 RatePolicy 인터페이스를 구현해야 한다는 것을 의미

---

하나의 클래스만 추가하고 란타임에 필요한 정책들을 조합해서 원하는 기능을 얻을 수 있다.

요구사항을 변경할 때 오직 하나의 클래스만 수정해도 된다느 ㄴ것.

# 믹스인

객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법

- 합성 : 실행 시점에 객체를 조합하는 재사용 방법
- 믹스인 : 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법

부가 정책은 항상 기본 정책의 처리가 완료된 후에 실행 된다.

TaxablePolicy는 BasicRatePolicy의 calculateFee 메서드를 오버라이딩한 후 super 호출을 통햇 먼저 BasicRatePolicy의 calculateFee 메서드를 실행한 후 자신의 처리를 수행한다.

```scala
trait TaxablePolicy extends BasicRatePolicy {
	def taxRate: Double

	override def calculateFee(phone: Phone): Money = }
		val fee = super.calculateFee(phone)
		fee - discountAmount
	}
}
```

```scala
class TaxableRegularPolicy(
	amount: Money,
	secound: Duration,
	val taxRate: Double)
extends RegularPolicy(amount, seconds)
with TaxablePolicy
```

스칼라

- 특정 클래스에 믹스인한 클래스와 트레이트를 “선형화”해서 어떤 메서드를 호출할지 결정한다.

클래스의 인스턴스를 생성할 때 스칼라는 클래스 자신과 조상 클래스, 트레이트를 일렬로 나열해서 순선를 정한다.

그리고 실행 중인 메서드 내부에서 super 호출을 하면 다음 단계에 위치한 클래스나 트레이트를 메서드가 호출된다.

**추상 서브 클래스**라고 부르기도 한다.

> 믹스인의 주요 아이디어는 매우 간단하다. 객체지향 언어에서 슈퍼클래스는 서브클래스를 명시하지 않고도 정의될 수 있다. 그러나 이것은 대칭적이지는 않다. 서브클래스가 정의될 때는 슈퍼클래스를 명시해야 한다. 믹스인(추상 서브클래스라고도 한다)은 결론적으로는 슈퍼클래스로부터 상속될 클래스를 명시하는 메커니즘을 표현한다. 따라서 하나의 믹스인은 매우 다양한 클래스를 도출하면서 서로 다른 서브클래스를 이용해 인스턴스화될 수 있다. 믹스인의 이런 특성은 다중 클래스를 위한 단일의 점진적인 확장을 정의하는 데 적절하게 만든다. 이 클래스들 중 하나를 슈퍼클래스로 삼아 믹스인이 인스턴스화될 때 추가적인 행위가 확장된 클래스를 생성한다.
> 

**쌓을 수 있는 변경**

> 스칼라에서 트레이트는 코드 재상용의 근간을 이루는 단위다. 트레이트로 메서드와 필드 정의를 캡슐화하면 트레이트를 조합한 클래스에서 그 메서드나 필드를 재사용할 수 있다. 하나의 부모 클래스만 갖는 클래스의 상속과 달리 트레이트의 경우 몇 개라도 믹스인될 수 있다. .. 클래스와 트레이트의 또 다른 차이는 클래스에서는 super 호출을 정적으로 바인딩하지만, 트레이트에서는 동적으로 바인딩한다는 것이다. super.toString이라는 표현을 어떤 ㅡㅋㄹ래스에서 사용하면 어떤 메서드 구현을 호출할지 정확하게 알 수 있따. 하지만 트레이트에 같은 내용을 작성해도 트레이트를 정의하는 시점에는 super가 호출할 실제 메서드 구현을 알 수 없다. 호출할 메서드의 구현은 트레이트를 클래스 구현에 믹스인할 때마다 (클래스에 따라) 새로 정해진다. super가 이렇게 동작하기 때문에 트레이트를 이용해 변경 위에 변경을 쌓아 올리는 쌓을 수 있는 변경이 가능해진다.
> 

---

# 느낀바

- 앞 자에서 사용되었던 기법들을 이제 논리적으로 정리하면서 개념을 다시금 설명하는 느낌이다.
    - 영화관의 할인정책이 interface로 정의를 하여 DI 개념을 설명을 하였는데 동일한 방법으로 합성에 관련되어 논의를 한다.
- 합성 관계에 있어서 어떠한 점들이 장점이 되는지에 대해 문제를 제출할 수 있을 것 타다.
# 서브클래싱과 서브타이핑

### 상속의 두가지 용도

- 타입 계층을 구현
  - 서브 타이핑 (인터페이스 상속)
  - 부모클래스는 일반적인 개념
  - 자식클래스는 부모클래스의 특수화

- 코드의 재사용 (이 용도로 쓰면 안됨)
  - 구현 상속 (클래스 상속)

### 객체지향 프로그래밍 관점에서의 타입

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 재공하는 객체들은 동일한 타입으로 분류된다.

### 언제 상속을 사용해야 하는가?

1. 상속 관계가 is-a 관계를 모델링 하는가? (일반화)

    [자식 클래스]는 [부모 클래스] 라고 말해도 이상하지 않다면 상속을 사용할 후보이다.


2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

    클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. 

    자식 클래스와 부모 클래스 사이의 행동 호환성


여기서 1번보다는 2번이 더 명확하다. 1번만으로는 예외 케이스가 존재한다. 

ex) 새라는 타입에서 fly인터페이스가 있다. 펭귄은 새이다. (is-a 만족) 그러나 펭귄은 날지 못함.

따라서 단순히 타입을 이름이나, 개념사이의 연관성으로 묶어내는 것은 옳지 못하다.

이보다 중요한 것은 **행동(퍼블릭 인터페이스)의 연관성**을 고려해야 한다.

그리고 이 행동은 클라이언트가 기대하는 행동이다. 

**자연어에 현혹되지 말고, 클라이언트가 기대하는 행동**에 집중하자.

[ 참고 ]

오히려 1번의 is-a는 2번을 만족하는 상황에서 타입의 이름을 지을 때, is-a로 연결해 문장을 만들어도 어색하지 않은지 고민하는 용도로 사용하는 것이 좋다.

즉 타입 이름을 정하는 가이드로 활용하는 편이 좋다.

### 리스코프 치환 원칙 (행동 호환성)

서브타입은 그것의 기반타입에 대해 대체 가능해야 한다.

클라이언트가 차이점을 인식하지 못한 채 인터페이스를 통해 서브 클래스를 사용해야 한다.

마찬가지로 is-a라는 직관보다는, 퍼블릭 인터페이스를 사용할 때 일관성있게 처리하는지가 중요하다.

퍼블릭 인터페이스의 사용 -> **클라이언트의 관점**.

**대체 가능성을 결정하는 것은 클라이언트**이다. 

참고 ) 위반 예시 -> 정사각형은 직사각형이다. super - 직사각형 , sub 정사각형 

### 리스코프 치환 원칙과 확장성

리스코프 치환 원칙은 확장성과도 연관이 있다.

클라이언트 관점에서 서브타입이 그것의 기반타입을 대체할 수 있다

-> 클라이언트의 수정 없이 새로운 서브 타입을 늘려가면서 기능을 확장할 수 있다.

### 계약에 의한 설계와 서브타이핑

클라이언트와 슈퍼타입의 인스턴스 사이에는 어떠한 계약이 맺어져 있다.

서브타입이 슈퍼타입처럼 보이기 위해서는 클라이언트가 슈퍼타입과 맺은 계약을 서브타입도 준수해야 한다.


**[ 계약의 종류 ]**

- 사전조건

  - 서브타입에 더 강력한 사전조건을 정의할 수 없다
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.

- 사후조건

  - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
  - 서브타입에 더 약한 사후조건을 정의할 수 없다.

- 클래스 불변식? (본 13장에선 구체적인 언급이 없는데 부록에 있는듯)

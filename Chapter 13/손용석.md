# 13. 서브클래싱과 서브타이핑

상속의 용도

1. 타입계층을 구현
    
    부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
    
2. 코드 재사용
    
    간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법의 주문.
    
    재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다
    

동일한 메시지에 대해 **서로 다르게 행동**할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.

# 타입

### 개념 관점의 타입

타입 : 우리가 인지하는 세상의 사물의 종류를 의미, 사물을 분류하기 위한 틀

자바, 루비, 자바스크립트, C - 프로그래밍 언어 ( 프로그래밍 언어라는 타입으로 분류 )

어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부른다.

자바, 루비, 자바스크립, C는 프로그래밍 언어의 인스턴스이다.

일반적으로 타입의 인스턴스를 객체라고 부른다.

- 심볼 : 타입에 이름을 붙인것
    
    **프로그래밍 언어**
    
- 내연 : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
    
    일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성
    
    **컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합**
    
- 외연 : 타입에 속하는 객체들의 지합
    
    **자바, 루비, 자바스크립트, C가 외연을 구성**
    

### 프로그래밍 언어 관점의 타입

1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공

적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.

### 객체지향 패러다임 관점의 타입

1. 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
2. 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합

객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미.

객체의 타입이란, 객체가 수신할 수 있는 메시지의 종류를 정의하는 것.

**→ 퍼블릭 인터페이스**

> 객체의 퍼블릭 인터피에스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
> 

객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.

객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하라.

# 타입 계층

타입 계층을 구성하는 두 타입 간의 관계

- 슈퍼타입 : 더 일반적인 타입
    - 집합이 다른 지합의 모든 멤버를 포함한다.
    - 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 서브타입 : 더 특수한 타입
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
    - 타입 정의가 다른 타입보다 좀 더 구체적이다.

내연 관점

일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정

특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정

외연 관점

슈퍼셋: 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함

서브셋: 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함 

### 객체지향 프로그래밍과 티입 계층

객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.

슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.

서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.

# 서브클래싱과 서브타이핑

두 질문이 모두 “예” 일 경우에 상속을 사용하라고 조언한다.

1. 상속 관계가 is-a 관계를 모델링하는가?
    
    일반적으로 “자식클래스”는 “부모클래스”다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
    
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    
    상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.
    
    이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.
    

### is-a 관계

- 펭귄은 새다.
- 새는 날 수 있다.

“펭귄은 새고, 따라서 날 수 있다” ⇒ 잘못된 이야기이다. 펭귄은 새가 맞으나 날 수 없다.

어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.

어떤 애플리케이션에서 새에게 날 수 있다는 행동을 기대하지 않고 단지 울음 소리를 낼 수 있다는 행동만 기대를 한다면 새와 펭귄을 타입 계층으로 묶어도 무방한다.

슈퍼타입과 서브타입 관계에서는 is-a 보다 행동 호환성이 더 중요하다.

### 행동 호환성

행동 호환 여부를 판단하는 기준은 **클라이언트의 관점**.

클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.

클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.

> 인터페이스 분리 원칙
이 원칙은 ‘비대한’ 인터페이스의 단점을 해결한다. 비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스다. 즉, 이러한 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원한다.

비대한 클래스는 그 클라이언트 사이에 이상하고 해로운 결합이 생기게 만든다. 한 클라이언트가 이 비대한 클래스에 변경을 가하면, 나머지 모든 클래스가 영향을 받게 된다. 그러므로 클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야만 한다. 이것은 이 비대한 클래스의 인터페이스를 여러 개의 클라이언트에 특화된 인터페이스로 분리함으로써 성취될 수 있다. 이렇게 하면 호출하지 않는 메서드에 대한 클라이언트의 의존성을 끊고, 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.
> 

**설계가 꼭 현실 세계를 반영할 필요는 없다.**

중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동이다.

### 서브클래싱과 서브타이핑

서브클래싱

다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가르킨다. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다. 서브클래싱을 구현상속 또는 클래스 상속이라고 부르기도 한다.

클래스의 내부 구현 자체를 상속받는 것에 초점을 맞추기 때문에 구현 상속 또는 클래스 상속이라고 부른다.

서브타이핑

타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 자식 클래스와 부모 클래스의 행동이 호환되기때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.

인터페이스 상속이라고 부르기도 한다. 

슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해 만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터피에스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다는 것이다. → 따라서 개념적으로 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보인다.

행동호환성을 만족시켜야한다

# 리스코프 치환 원칙

```java
public class Rectangle {
	private int x, y, width, height;

	public Rectangle(int x, int y, int width, int height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.heigth = height;
	}

	public int getWidth() {
		return width;
	}

	public void setWidth(int width) {
		this.width = width;
	}

	public int getHeight() {
		return height;
	}

	public void setHeight(int height) {
		this.height = height;
	}

	public int getArea() {
		return widht * height;
	}
}

public class Square extends Rectangle {
	public Square(int x, int y, int size) {
		super(x, y, size, size) {
	}

	@Override
	public void setWidth(int width) {
		super.setWidth(width);
		super.setHeight(width);
	}

	@Override
	public void setHegith(int height) {
		super.setWidth(height);
		super.setHeight(height);
	}
}

public void resize(Rectangle rectangle, int width, int height) {
	rectange.setWidth(witdh);
	rectange.setHeight(height);
	assert rectagle.getWidth() == width && rectangle.getHeight() == height;
}
```

resize 메서드의 구현은 Rectangle이 세운 가정에 기반하기 때문에 직사각형의 너비와 높이를 독립적으로 변경할 수 있다고 가정한다.

하지만 Rectangle의 자리에 Square를 전달할 경우 이 가정은 무너지고 만다.

Square일 경우, setHeight로 인해서 height의 값으로 width가 변경이 된다. 그렇기에 getWidth() == width가 오류를 뱉어낸다

Square는 Recatangle의 구현을 재사용하고 있을 뿐이다.

리스코프 치환 원칙을 위반하기 때문에, **서브클래싱 관계**이다.

### 클라이언트와 대체 가능성

리스코프 치환 원칙

 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.

클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다

어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다는 것

### is-a 관계 다시 살펴보기

클라이언트 관점에서 is-a 일 때만 참이다.

객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.

일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.

# 계약에 의한 설계와 서브타이핑

계약에 의한 설계

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약 관점에서 표현하는 것.

클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 **사전조건**과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 **사후조건**, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 **클래스 불변식**의 세 가지 요소로 구성된다.

### 서브타입과 계약

계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있따는 것.

**서브타입에 더 강력한 사전 조건을 정의할 수 없다.**

**서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.**

**서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.**

**서브타입에 더 약한 사후조건을 정의할 수 없다.**

---

# 느낀바

- 서브클래싱과 서브타이핑에 관련되어 알게 되었다.
- 상속을 제대로 구현하기 위해서는 리스코프치환 원칙이 중요하다는 것과 행동이 중요한 것을 깨달았다.
    - 단순한 코드 재사용으로 인해 상속을 사용하게 된다면, 리스코프 치환 원칙이 깨져서 크나큰 문제를 야기할 것이다.

상속에 관련되어 다음과 같은 질문을 할 수 있을 것 같다.

1. 설계를 할 때 상속에 관련되어 어떤 관점에서 선택을 하게 되는가?
    1. 그러한 선택에 어떠한 기반의 근거가 깔려있는가?
2. 상속 이후, 자식 클래스에서 Override하여 재정의할 때 고려해야하는 사안들은 어떤 것들이 있는가?
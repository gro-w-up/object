### 🧭 방향
- 목표 : 그룹 스터디 진행을 효과적으로 관리하기 위해 저장소를 운영한다.

### ⌚ 매주 주말 1회 1시간
- 장소 : 디스코드

### 🤔 방식
- 1️⃣ object 프로젝트를 자신의 계정으로 fork합니다.
- 2️⃣ fork한 repository를 개인 컴퓨터에 clone합니다.
- 3️⃣ 매 주 목표의 독서량을 읽고 정리하여 코드 저장(commit) & 개인 원격 저장소 저장(push)를 합니다.
- 4️⃣ github에서 PR(pull request)를 작성합니다.
  + PR 출발지는 fork한 자신의 저장소의 3️⃣번에서 생성한 branch로 합니다.
  + ex) object:master <- object:origin/master
- 5️⃣ 커밋 메시지를 작성합니다. PR 규칙 및 Commet Message 규칙 참고
- 6️⃣ PR들을 merge합니다.
- 7️⃣ **독서량에서 읽었던 내용 중 면접 질문을 만들거나 깨달은 점 의문이 들었던점을 마크다운으로 정리하여 공유합니다.**
- 8️⃣ 이후, 각자 본인의 폴더에 장.별로 구분하여 동일한 방식(1-6)으로 코드를 관리하며 스터디를 완료합니다.

### 패키지 구성 가이드
```
Chapter 1
ㄴ 01. 티켓판매 애플리케이션 구현하기
  ㄴ 우연.md
```

### 🤙🏻 PR 규칙 및 Commit Message 규칙
- Pull Request (공용 저장소)
  + 이름 장 제목
  + ex) docs: 우연 1장 완료

- Commit Message (개인 저장소)
  + 장 제목
  + ex) 1장 ~~ 완료

### 목차
▣ 들어가며: 프로그래밍 패러다임  
01. 패러다임의 시대  
02. 프로그래밍 패러다임  

▣ 1장: 객체, 설계
01. 티켓 판매 애플리케이션 구현하기
02. 무엇이 문제인가  
- [x] 예상을 빗나가는 코드  
- [x] 변경에 취약한 코드
03. 설계 개선하기  
- [x] 자율성을 높이자  
- [x] 무엇이 개선됐는가  
- [x] 어떻게 한 것인가  
- [x] 캡슐화와 응집도  
- [x] 절차지향과 객체지향  
- [x] 책임의 이동  
- [x] 더 개선할 수 있다  
- [x] 그래, 거짓말이다!
04. 객체지향 설계  
- [x] 설계가 왜 필요한가  
- [x] 객체지향 설계

▣ 2장: 객체지향 프로그래밍
01. 영화 예매 시스템  
- [x]  요구사항 살펴보기
02. 객체지향 프로그래밍을 향해  
- [x]  협력, 객체, 클래스  
- [x]  도메인의 구조를 따르는 프로그램 구조  
- [x]  클래스 구현하기  
- [x]  협력하는 객체들의 공동체  
- [x]  협력에 관한 짧은 이야기
03. 할인 요금 구하기  
- [x]  할인 요금 계산을 위한 협력 시작하기  
- [x]  할인 정책과 할인 조건  
- [x]  할인 정책 구성하기
04. 상속과 다형성  
- [x]  컴파일 시간 의존성과 실행 시간 의존성  
- [x]  차이에 의한 프로그래밍  
- [x]  상속과 인터페이스  
- [x]  다형성  
- [x]  인터페이스와 다형성
05. 추상화와 유연성  
- [x]  추상화의 힘  
- [x]  유연한 설계  
- [x]  추상 클래스와 인터페이스 트레이드오프  
- [x]  코드 재사용  
- [x]  상속  
- [x]  합성

▣ 3장: 역할, 책임, 협력
01. 협력  
- [x]  영화 예매 시스템 돌아보기  
- [x]  협력  
- [x]  협력이 설계를 위한 문맥을 결정한다
02. 책임  
- [x]  책임이란 무엇인가  
- [x]  책임 할당  
- [x]  책임 주도 설계  
- [x]  메시지가 객체를 결정한다  
- [x]  행동이 상태를 결정한다
03. 역할  
- [x]  역할과 협력  
- [x]  유연하고 재사용 가능한 협력  
- [x]  객체 대 역할  
- [x]  역할과 추상화  
- [x]  배우와 배역

▣ 4장: 설계 품질과 트레이드오프
01. 데이터 중심의 영화 예매 시스템  
- [x]  데이터를 준비하자  
- [x]  영화를 예매하자
02. 설계 트레이드오프  
- [x]  캡슐화  
- [x]  응집도와 결합도
03. 데이터 중심의 영화 예매 시스템의 문제점  
- [x]  캡슐화 위반  
- [x]  높은 결합도  
- [x]  낮은 응집도  
- [x]  캡슐화를 지켜라
04. 자율적인 객체를 향해  
- [x]  스스로 자신의 데이터를 책임지는 객체  
- [x]  캡슐화 위반
05. 하지만 여전히 부족하다  
- [x]  높은 결합도  
- [x]  낮은 응집도  
- [x]  데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다
06. 데이터 중심 설계의 문제점  
- [x]  데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

▣ 5장: 책임 할당하기
01. 책임 주도 설계를 향해  
- [x]  데이터보다 행동을 먼저 결정하라  
- [x]  협력이라는 문맥 안에서 책임을 결정하라  
- [x]  책임 주도 설계
02. 책임 할당을 위한 GRASP 패턴  
- [x]  도메인 개념에서 출발하기  
- [x]  정보 전문가에게 책임을 할당하라  
- [x]  높은 응집도와 낮은 결합도  
- [x]  창조자에게 객체 생성 책임을 할당하라
03. 구현을 통한 검증  
- [x]  DiscountCondition 개선하기  
- [x]  타입 분리하기  
- [x]  다형성을 통해 분리하기  
- [x] 변경으로부터 보호하기  
- [x]  Movie 클래스 개선하기  
- [x]  변경과 유연성
04. 책임 주도 설계의 대안  
- [x]  메서드 응집도  
- [x]  객체를 자율적으로 만들자

▣ 6장: 메시지와 인터페이스
01. 협력과 메시지  
- [x]  클라이언트- 서버 모델  
- [x]  메시지와 메시지 전송  
- [x]  메시지와 메서드  
- [x]  퍼블릭 인터페이스와 오퍼레이션  
- [x]  시그니처
02. 인터페이스와 설계 품질  
- [x]  묻지 말고 시켜라  
- [x]  의도를 드러내는 인터페이스  
- [x]  함께 모으기
03. 원칙의 함정  
- [x]  디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다  
- [x]  결합도와 응집도의 충돌
04. 명령- 쿼리 분리 원칙  
- [x]  반복 일정의 명령과 쿼리 분리하기  
- [x]  명령- 쿼리 분리와 참조 투명성  
- [x]  책임에 초점을 맞춰라

▣ 7장: 객체 분해
01. 프로시저 추상화와 데이터 추상화
02. 프로시저 추상화와 기능 분해  
- [x]  메인 함수로서의 시스템  
- [x]  급여 관리 시스템  
- [x]  급여 관리 시스템 구현  
- [x]  하향식 기능 분해의 문제점  
- [x]  언제 하향식 분해가 유용한가?
03. 모듈  
- [x]  정보 은닉과 모듈  
- [x]  모듈의 장점과 한계
04. 데이터 추상화와 추상 데이터 타입  
- [x]  추상 데이터 타입
05. 클래스  
- [x]  클래스는 추상 데이터 타입인가?  
- [x]  추상 데이터 타입에서 클래스로 변경하기  
- [x]  변경을 기준으로 선택하라  
- [x]  협력이 중요하다

▣ 8장: 의존성 관리하기
01. 의존성 이해하기  
- [x]  변경과 의존성  
- [x]  의존성 전이  
- [x]  런타임 의존성과 컴파일타임 의존성  
- [x]  컨텍스트 독립성  
- [x]  의존성 해결하기
02. 유연한 설계  
- [x]  의존성과 결합도  
- [x]  지식이 결합을 낳는다  
- [x]  추상화에 의존하라  
- [x]  명시적인 의존성  
- [x]  new는 해롭다  
- [x]  가끔은 생성해도 무방하다  
- [x]  표준 클래스에 대한 의존은 해롭지 않다  
- [x]  컨텍스트 확장하기  
- [x]  조합 가능한 행동

▣ 9장: 유연한 설계
01. 개방- 폐쇄 원칙  
- [x]  컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라  
- [x]  추상화가 핵심이다
02. 생성 사용 분리  
- [x]  FACTORY 추가하기  
- [x]  순수한 가공물에게 책임 할당하기
03. 의존성 주입  
- [x]  숨겨진 의존성은 나쁘다
04. 의존성 역전 원칙  
- [x]  추상화와 의존성 역전  
- [x]  의존성 역전 원칙과 패키지
05. 유연성에 대한 조언  
- [x]  유연한 설계는 유연성이 필요할 때만 옳다  
- [x]  협력과 책임이 중요하다

▣ 10장: 상속과 코드 재사용
01. 상속과 중복 코드  
- [x]  DRY 원칙  
- [x]  중복과 변경  
- [x]  상속을 이용해서 중복 코드 제거하기  
- [x]  강하게 결합된 Phone과 NightlyDiscountPhone
02. 취약한 기반 클래스 문제  
- [x]  불필요한 인터페이스 상속 문제  
- [x]  메서드 오버라이딩의 오작용 문제  
- [x]  부모 클래스와 자식 클래스의 동시 수정 문제
03. Phone 다시 살펴보기  
- [x]  추상화에 의존하자  
- [x]  차이를 메서드로 추출하라  
- [x]  중복 코드를 부모 클래스로 올려라  
- [x]  추상화가 핵심이다  
- [x]  의도를 드러내는 이름 선택하기  
- [x]  세금 추가하기
04. 차이에 의한 프로그래밍

▣ 11장: 합성과 유연한 설계
01. 상속을 합성으로 변경하기  
- [x]  불필요한 인터페이스 상속 문제: java.util.Properties와 java.util.Stack  
- [x]  메서드 오버라이딩의 오작용 문제: InstrumentedHashSet  
- [x]  부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist
02. 상속으로 인한 조합의 폭발적인 증가  
- [x]  기본 정책과 부가 정책 조합하기  
- [x]  상속을 이용해서 기본 정책 구현하기  
- [x]  기본 정책에 세금 정책 조합하기  
- [x]  기본 정책에 기본 요금 할인 정책 조합하기  
- [x]  중복 코드의 덫에 걸리다
03. 합성 관계로 변경하기  
- [x]  기본 정책 합성하기  
- [x]  부가 정책 적용하기  
- [x]  기본 정책과 부가 정책 합성하기  
- [x]  새로운 정책 추가하기  
- [x]  객체 합성이 클래스 상속보다 더 좋은 방법이다
04. 믹스인  
- [x]  기본 정책 구현하기  
- [x]  트레이트로 부가 정책 구현하기  
- [x]  부가 정책 트레이트 믹스인하기  
- [x]  쌓을 수 있는 변경

▣ 12장: 다형성
01. 다형성
02. 상속의 양면성  
- [x] 상속을 사용한 강의 평가  
- [x] 데이터 관점의 상속  
- [x] 행동 관점의 상속
03. 업캐스팅과 동적 바인딩  
- [x] 같은 메시지, 다른 메서드  
- [x] 업캐스팅  
- [x] 동적 바인딩
04. 동적 메서드 탐색과 다형성  
- [x] 자동적인 메시지 위임  
- [x] 동적인 문맥  
- [x] 이해할 수 없는 메시지  
- [x] self 대 super
05. 상속 대 위임  
- [x] 위임과 self 참조  
- [x] 프로토타입 기반의 객체지향 언어

▣ 13장: 서브클래싱과 서브타이핑
01. 타입  
- [x] 개념 관점의 타입  
- [x] 프로그래밍 언어 관점의 타입  
- [x] 객체지향 패러다임 관점의 타입
02. 타입 계층  
- [x] 타입 사이의 포함관계  
- [x] 객체지향 프로그래밍과 타입 계층
03. 서브클래싱과 서브타이핑  
- [x] 언제 상속을 사용해야 하는가?  
- [x] is- a 관계  
- [x] 행동 호환성  
- [x] 클라이언트의 기대에 따라 계층 분리하기  
- [x] 서브클래싱과 서브타이핑
04. 리스코프 치환 원칙  
- [x] 클라이언트와 대체 가능성  
- [x] is- a 관계 다시 살펴보기  
- [x] 리스코프 치환 원칙은 유연한 설계의 기반이다  
- [x] 타입 계층과 리스코프 치환 원칙
05. 계약에 의한 설계와 서브타이핑  
- [x] 서브타입과 계약

▣ 14장: 일관성 있는 협력
01. 핸드폰 과금 시스템 변경하기  
- [x] 기본 정책 확장  
- [x] 고정요금 방식 구현하기  
- [x] 시간대별 방식 구현하기  
- [x] 요일별 방식 구현하기  
- [x] 구간별 방식 구현하기
02. 설계에 일관성 부여하기  
- [x] 조건 로직 대 객체 탐색  
- [x] 캡슐화 다시 살펴보기
03. 일관성 있는 기본 정책 구현하기  
- [x] 변경 분리하기  
- [x] 변경 캡슐화하기  
- [x] 협력 패턴 설계하기  
- [x] 추상화 수준에서 협력 패턴 구현하기  
- [x] 구체적인 협력 구현하기  
- [x] 협력 패턴에 맞추기  
- [x] 패턴을 찾아라

▣ 15장: 디자인 패턴과 프레임워크
01. 디자인 패턴과 설계 재사용  
- [x] 소프트웨어 패턴  
- [x] 패턴 분류  
- [x] 패턴과 책임- 주도 설계  
- [x] 캡슐화와 디자인 패턴  
- [x] 패턴은 출발점이다
02. 프레임워크와 코드 재사용  
- [x] 코드 재사용 대 설계 재사용  
- [x] 상위 정책과 하위 정책으로 패키지 분리하기  
- [x] 제어 역전 원리

▣ 마치며: 나아가기

▣ 부록A: 계약에 의한 설계
01. 협력과 계약  
- [x] 부수효과를 명시적으로  
- [x] 계약
02. 계약에 의한 설계  
- [x] 사전조건  
- [x] 사후조건  
- [x] 불변식
03. 계약에 의한 설계와 서브타이핑  
- [x] 계약 규칙  
- [x] 가변성 규칙  
- [x] 함수 타입과 서브타이핑

▣ 부록B: 타입 계층의 구현  
- [x] 클래스를 이용한 타입 계층 구현  
- [x] 인터페이스를 이용한 타입 계층 구현  
- [x] 추상 클래스를 이용한 타입 계층 구현  
- [x] 추상 클래스와 인터페이스 결합하기  
- [x] 덕 타이핑 사용하기  
- [x] 믹스인과 타입 계층

▣ 부록C: 동적인 협력, 정적인 코드
01. 동적 모델과 정적 모델  
- [x] 행동이 코드를 결정한다  
- [x] 변경을 고려하라
02. 도메인 모델과 구현  
- [x] 도메인 모델에 관하여  
- [x] 몬스터 설계하기  
- [x] 행동과 변경을 고려한 도메인 모델  
- [x] 분석 모델, 설계 모델, 그리고 구현 모델

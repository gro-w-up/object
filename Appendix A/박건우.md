# 계약에 의한 설계 

계약을 통해서 제약 조건을 명시적으로 표현할 수 있고, 이것을 문서화 할 수 있다.

왜 처음들어보나 했더니 자바에서는 지원을 안하는구나

## 계약의 세가지 요소

- 사전 조건
  - 메서드가 호출되기 위해 만족돼야하는 조건.
  - 클라이언트의 의무.
  - 사전조건이 만족되지 않으면 메서드가 실행되면 안된다.

- 사후 조건
  - 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건
  - 서버의 의무
  - 사전조건이 만족되었는데도, 사후조건을 만족시키지 못하면 예외를 던져야함

- 불변식
  - 항상 참이라고 보장되는 서버의 조건
  - 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이여야 한다.


## 계약에 의한 설계의 장점

계약에 의한 설계를 도와주는 라이브러리를 사용하면 여러 장점이 있음.

### 사전 조건

- 제약 조건을 자동으로 문서화 가능.
- 인터페이스의 시그니처만으로 부족한 정보를 보충해줌.
- 일반적인 validation보다 명확하게 표현 가능함.

### 사후조건

- return문이 여러개 있을 때 한곳에만 작성해도 됨.
- 메서드 실행 전 상태에 접근하기 쉬움.

### 불변식

불변식은 생성자 실행후, 메서드 실행 전, 후에 호출된다.
계약 라이브러리를 사용하면 일일히 호출되는 타이밍을 관리하지 않아도 된다.

## 계약에의한 설계와 서브타이핑

클라이언트 입장에서는 슈퍼타입만 바라보고 있음(=슈퍼타입을 보고 계약을 함.).

**클라이언트의 입장에서 생각해보면 이해하기 쉽다.**

### 계약 규칙


- 서브 타입에 더 강력한 사전 조건을 정의할 수 없다.
  - 클라이언트의 입장에서는 알고 있던 계약 내용보다 더 까다로워짐.

- 서브 타입에 더 완화된 사후 조건을 정의할 수 없다.
  - 클라이언트 입장에서는 반환 내용이 알고 있던 계약 내용과 다르게 됨. 

- 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.


### 가변성 규칙 (제네릭 프로그래밍을 공부할 때 도움이 된다고 한다.)

- 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.

- 서브타입의 리턴 타입은 공변성을 가져야 한다. 

   (공변성 -> 리스코프 치환 원칙. 서브타입이 슈퍼타입 대신 사용 가능)

   - 반환 타입의 서브 타입을 반환해도 상관 없다.

   - 리턴 타입이 서브 타입인 것은 더 강화된 사후조건을 정의하는 것 과 같다. 따라서 문제가 없다.

- 서브타입의 메서드 파라미터는 반공변성을 가져야한다.

   - 오버라이딩 할 때 슈퍼타입의 메서드 파라미터보다, 상위타입의 메서드 파라미터를 사용 해도 된다.

   - 서브타입의 매개변수로 슈퍼타입을 받는다는 것은 사전 조건을 약화시키는 것이기 때문에 상관 없다.
   
   - 단 자바는 이러한 반공변성을 지원하지 않는다.


[참고]

함수의 타입을 정의할 수 있는 언어들이 있는데,  (파라미터와 반환타입으로 함수의 타입을 정의함.)

위의 가변성 규칙을 알고 있으면 함수 사이의 슈퍼타입 서브타입 관계를 이해할 수 있다.

메서드 파라미터 -> 슈퍼타입 사용 가능

메서드 반환 -> 서브타입 사용 가능


\

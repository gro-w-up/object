# 10. 상속과 코드 재사용
 
## 책을 읽기 전 목차를 보았을 때 떠오르는 생각들
- 중복코드를 추출하여 부모클래스로 올리는 작업을 진행하겠군
- 불필요한 인터페이스 상속이란 무엇인지 더 자세히 봐야겠다.
- 추상화에 의존하자는 이야기는 DI와 연관된 내용인가?

### 질문할 수 있는 것들
1. 상속이란 무엇인가?
2. DRY 원칙과 관련된 리팩토링 기법에 대해서 아는바가 있으면 말해보시오
3. 추상화라는 개념에 대해서 설명하시오
    1. 추상화를 활용하여 코드를 짠 경험이 있다면 거기에 대해서 설명하시오

## 01. 상속과 중복코드
### DRY 원칙
`Don't Repeat Yourself` : 동일한 지식을 중복하지 말라
- 한 번, 단 한번 원칙 또는 단일 지점 제어원칙 이라고도 부른다.

중복 여부의 판단 기준
요구 사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복.
모양이 유사하다는 것은 단지 중복의 징후

변경에 반응하는 방식이 중요.

### 중복과 변경
요구 사항의 변경
- '심야 할인 요금제': 밤 10시 이후의 통화에 대해 요금을 할인 해주는 방식
- 기존의 요금제를 '일반 요금제'라고 부른다.

Me) 기존의 Phone을 상속 받아 '심야 할인 요금제'에서는 `super()`를 호출한 후 추가적인 할인을 진행하겠다

책에서는, 일단 기존의 Phone을 복사하여 새로운 NightlyDiscountPhone을 만들었다.

#### 타입 코드 사용하기
- 요금제를 구분하는 타입 코드를 추가하고 타입 코드의 값에 다라 로직을 분기시켜 `Phone`과 `NightlyDiscountPhone`을 하나로 합칠 수 있다.
- 타입 코드를 사용하는 클래스는 **낮은 응집도**와 **높은 결합도**라는 문제에 시달리게 된다.
### 상속을 이용해서 중복 코드 제거하기
상속을 이용해 코드를 재사용한다.

1. 10시 이전의 요금을 Phone에서 결정 (super() 사용)
    1. 10시 이전의 요금을 계산하는데 필요한 regulareAmount와 seconds를 생성자에 전달.
2. 10시 이후의 요금을 전체 요금에서 차감한다.
    1. 10시 이전의 요금이 10시 이후의 요금보다 더 비싸기 때문이다.

-> 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각보다 쉽지 않다.
재사용을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다.
그 가정은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다.

### 강하게 결합된 Phone과 NightlyDiscountPhone
코드 중복을 제거하기 위해 상속을 사용했음에도 세금을 계산하는 로직을 추가하기 위해 새로운 중복 코드를 만들어야한다.
- `Phone`을 수정할때, 유사한 코드를 `NightlyDiscountPhone`에도 추가해야한다.

> Super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

Me: Super를 활용하여 코드 중복을 막으려고 하였으나 조금은 다시 고려해볼 것을 책을 통해 생각하게 됨.

**기반 클래스 문제**
상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다.

## 02. 취약한 기반 클래스 문제
상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 <u>근본적인 취약성</u>이다.

**상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다.**
- 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데 용이함.
- 하지만, 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.
    - 최악의 경우: 모든 자식 클래스를 동시에 수정하고 테스트해야할 수도 있다.

Q) 상속과 캡슐화에 관련도에 대해서 아는바에 대해 서술하시오
A) 상속을 하게 되면, 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.

### 불필요한 인터페이스 상속
Vector와 Stack의 관계

Vector
- 임의의 위치에 요소 정보를 가져올 수 있음.
- 임의의 위치에 요소 정보를 추가할 수 있음.
- 임의의 위치에 요소 정보를 제거 할 수 있음.

Stack
- Top 위치에 요소를 추가할 수 있음.
- Top 위치에 요소를 제거할 수 있음.
- 결코, 임의의 위치에 요소를 조회/추가/제거 할 수 없음.

자바 초기 버전에서는 Stack을 Vector를 **상속**받아 구현을 하였다.
> 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 꺠트릴 수 있다.

### 메서드 오버라이딩의 오작용

```Java
public class InstrumentedHashSet<E> extends HashSet<E> {
	private int addCount = 0;
	
	@Override
	public boolean add(E e) {
		addCount++;
		return super.add(e);
	}
	
	@Override
	public boolean addAll(Collection<? extends E> c) {
		addCount != c.size();
		return super.addAll(c)
	}
}
```

```Java
InstrumentedHashSet<String> languages = new InstrumentedHashSet<>();
languages.addAll(Arrays.asList("Java", "Ruby", "Scala"));
```

AddCount의 값은?
Expected: 3
Actual: 6

이유: `HashSet`의 `addAll` 함수에서 add 메소드를 호출하기 때문이다.
1. InstrumentedHashSet의 addAll 메서드가 호출돼서 addCount에 3이 더해진다.
2. super.addAll 메서드가 호출되고 제어는 부모 클래스인 HashSet으로 이동한다.
3. HashSet은 각각의 요소를 추가하기 위해 내부적으로 add 메서드를 호출
1. 결과적으로 InstrumentedHashSet의 add 메서드가 세번 호출되어 addCount에 3이 더해진다.

> 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

### 부모 클래스와 자식 클래스의 동시 수정 문제
서브클래스는 올바른 올바른 기능을 위해 슈퍼클래스의 세부적인 구현에 의존한다.
슈퍼클래스의 구현은 릴리스를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다.
- 슈퍼클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야한다.

> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
## 03. Phone 다시 살펴보기
### 추상화에 의존하자
부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정한다.
1. 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
2. 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있.

### 차이를 메서드로 추출하라
- 변하는 것으로부터 변하지 않는 것을 분리하라
- 변하는 부분을 찾고 이를 캡슐화하라
### 중복 코드를 부모 클래스로 올려라
- 모든 클래스들이 추상화에 의존하도록 새로운 부모 클래스를 생성하고 모두가 해당 추상클래스를 바라보도록 한다.
    - `AbstractPhone`

### 추상화가 핵심이다
### 의도를 드러내는 이름 선택
### 세금추가하기
인스턴스 변수가 추가 되는 경우, 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야 하기 때문에 자연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미치게 된다.
- 책임을 아무리 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발한다.

인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 코드를 중복시키는 것보다 현명한 선택이다.

## 04. 차이에 의한 프로그래밍
기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.


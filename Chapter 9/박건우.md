# 9장 유연한 설계
> 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화 관점에서 훌륭한 코드이다. <br>
> 클래스의 사용법을 익히기 위해 구현 내부를 사샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.

### 개방 폐쇄 원칙

- 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는것 만으로 기능을 확장할 수 있다.
- 확장에 대해서는 열려있고, 수정에 대해서는 닫혀있다.

### 추상화에 의존하자

추상화?
- 변하지 않는 부분(공통점)만 남기고, 문맥에 따라 변하는 부분은 생략한다.
- 이렇게 생략된 부분은 문맥에따라 적합하게 채워넣으면 된다.

```java
public abstract class DiscountPolicy {
    //변하지 않는부분
    private List<DiscountCondition> conditions = new ArrayList<>(); 
    
    ...   
    
    // 변하지 않는 부분
    public Money calculateDiscountMoney(Screening screening) { 
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening)
            }
        }
        
        return screening.getMovieFee(); 
    }
    
    // 문맥에 따라 변하는 부분
    abstract protected Money getDiscountAmount(Screening screening);
}
```

### 생성 사용 분리

> 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작 단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다

이래서 IoC 컨테이너를.... 

### 순수한 가공물 (Pure Fabircation)

- 도메인 개념을 표현하는 객체만으로는 부족한 경우가 발생한다
- ex) DB접근 객체, Factory와 같이 객체를 생성하는 객체
- 이처럼 책임을 할당하기 위해 창조되는 도메인과 무관한 인공객체를 '순수한 가공물' 이라고 부른다

실제 객체지향 애플리케이션은 도메인 객체 말고도, 이러한 순수한 가공물들로 가득 차있다. 

도메인 추상화가 전부가 아니다. 도메인 객체만으로는 만족스럽지 않다면 주저하지 말고 인공적인 객체를 만들자

### 의존성 주입

숨겨진 의존성은 나쁘다.

- 생성자에서 주입을 전부다 해주었는데, 의존객체가 null...?
- 단위 테스트코드 작성도 어렵다

모든 의존성은 객체의 퍼블릭 인터페이스에 명시적으로 노출시켜야한다.

의존성을 구현 내부에 숨기면 코드를 이해하기도, 수정하기도 어렵다

### 의존성 역전 원칙

- 상위 수준 모듈이 하위 수준 모듈에 의존하면 안된다.
- 추상화는 구체적인 사항에 의존해서는 안된다
- 하위 수준 모듈의 변경에 의해 상위 수준 모듈에 영향을 끼쳐서는 안된다.

왜 의존성'역전'?

- 전통적인 소프트웨어 개발에서는, 상위수준 모듈이 하위수준 모듈에 의존하는 경향이 있었다.
- 이러한 구조를 역전 시킨 것

의존성 역전과 패키지?

- Movie를 정상적으로 컴파일 하기위해서는 DiscountPolicy만 필요하다. (여타 구현체는 불필요)
- 인터페이스 계층과 구현계층을 분리해서 패키지 구조를 작성하자
- 빌드시간 단축

### 유연한 설계는 유연성이 필요할 때만 옳다

> 복잡성이 필요한 이유와 합리적인 근거를 제시하지 않는다면 어느 누구도 만족스러운 해법으로 받아들이지 않을 것이다.

- 유연한 설계 -> 복잡한 설계 (비례)
- 복잡성을 수용할 만큼 유연한 설계가 필요한가?

# 09. 유연한 설계

## 책을 읽기 전 목차를 보았을 때 떠오르는 생각들
1. 개방-폐쇄 원칙은 무엇인가?
2. 해당 원칙을 사용하면, 어떻게 유연한 설계가 이뤄질 수 있는가?
3. 해당 원칙을 사용한 코드의 예제는 어떻게 되는가?

## 01. 개방-폐쇄 원칙

- 개방-퍠쇄 원칙은 무엇인가?
  `소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀있어야한다.`
1. 확장 : 애플리케이션의 요구사항이 변경될 때, 새로운 `동작`을 추가해서 기능을 확장하는 것.
2. 닫혀있다. : 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.


### 컴파일러타임 의존성을 고정시키고 런타임 의존성을 변경하라
**[[컴파일러 타입 의존성]]**
코드에서 드러나는 클래스 사이들의 관계

	- 설계와 관련된 부분들이다. 우리들이 흔히 말하는 상속 관계들이 컴파일 타입 의존성에 해당을 한다.
**[[런타임 의존성]]**
실행 시에 협력에 참여하는 객체들 사이의 관계

	- App이 실행이 되어, 메모리 상에 할당이 되었을 때 알 수 있는 관계들이다.
	- 컴파일 타입 의존성에 의하여 발생하지만, 1:N 의 관계도가 아닌 1:1 관계도로 표현이 된다.

![Pasted image 20231216103907.png](Pasted%20image%2020231216103907.png)

해당 설계에서 새로운 할인 정책이 추가가 된다면 `DiscountPolicy`를 상속받는 새로운 클래스를 생성하는 것이다.
- 기존의 Policy 및 Movie 에는 영향을 주지 않는다.
    - `닫혀있다.`
- 새로운 기능이 추가가 되었다.
    - `확장`

#### 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.
개방-폐쇄 원칙을 잘 따르게 된다면, 컴파일 타임의 의존성인 Movie와 Policy 간의 변경이 없이 런타임 의존성을 쉽게 수정할 수 있다

Q. 과도한 추상화는 오버엔지니어링이 될 가능성이 있지 않을까?
- 위의 상황에서는 Policy 정책이 2개가 있기때문에 추상화의 정책이 매우 자연스러워 보인다. 하지만, 최초 기획에서 할인 정책이 1개만 있고 당시에는 더 이상의 할인 정책의 추가가 없다고 하였을 때에는 어떻게 설계를 하겠는가?

A. 클래스 간의 연관 관계를 보았을 때 Movie의 입장에서는 Policy 정책에서 안의 내용을 몰라도 되며, 겉으로는 단순히 할인에 대한 요청 사항만 던질 것이라고 판별이 된다. (은닉화)
그렇기 때문에,  Interface를 통하여 Moive 와 Policy 간의 의존도를 약화 시킬 것이게 될 것이다.
Code 파일이 다소 많이 늘어나 오버엔지니어링 혹은 코드를 읽는 관점에서 조금의 피로도가 늘어나게 될 것이라고 생각이 되나, Moive 도메인의 관점에서는 Policy가 가지고 있는 행동들에만 주목을 할 것이므로, Interface 로 나눠지는 것은 자연스러운 설계라고 보여진다.

### [[추상화]]가 핵심이다
개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 **의존성의 방향**이다.
추상화를 했다고 해서 모든 수정에 대해 설계가 폐쇄되는 것은 아니라는 것.
변하는 것과 변하지 않는 것이 무엇인지를 이해 -> 추상화 목적으로 삼아야하는 것.

## 02. 생성 사용 분리
알아야하는 지식이 많으면 결합도도 높아진다.
특히 객체 생성에 대한 지식은 `과도한 결합도`를 초래하는 경향이 있다.

물론 객체 생성은 필수적이다.
부적절한 곳에서 생성하는 것이 문제를 야기시킨다.

### 생성과 사용을 분리
- 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야한다.
    * TODO : 함수형 프로그래밍 책 읽고 덧붙히기

가장 보편적인 방법
- 객체를 생성할 책임을 클라이언트로 옮기는 것
    - 주입해주는 것과 비슷한 맥락으로 보인다. (나의 생각)
     ![Pasted image 20231216111109.png](Pasted%20image%2020231216111109.png)


- 내가 보기에는 전혀 이상할 것 없는 코드.
```Java
public Class Movie() {
	private DiscountPolicy discountPolicy;
	public Movie(String title, Duration runningTime, Money fee) {
		...
		this.discountPolicy = new AmountDiscountPolicy(....);
	}
	
	public Money calculateMovieFee(Screening screening) {
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
	
}
```

-> 하지만, 결합도가 매우 높은 코드 구조. 할인 정책이 변경이 되면, `Movie` 생성자의 `discountPolicy` 할당 부분을 변경해야한다.
물론, 할인정책에 관련되어 생성을 해줘야하겠지만 Movie가 이 정보까지 생성하면서 알아야하는 것은 요상하다.

- 내가 봤을 때는 너무 과도하게 생성자에 많이 들어가있는 모습.
```Java
public class Client {
	public Money getAvatarFee() {
		Movie avatar = new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000), new AmountDiscountPolicy(....));
		return avatar.getFee();
	}
}
```

-> Movie에게서 DiscountPolicy의 생성 정보를 떼내었다. (생성과 사용을 분리)
Avatar에게 새로운 할인정책이 할당되어도, Movie 객체를 수정하지 않아도 된다. 유연해졌다.

-> Client는 객체를 생성함과 동시에 사용을 하게 된다. (`getFree()`)
`Moive`의 생성을 client를 생성하는 곳에 위임하는 것은 어떠한가? (Movie를 설계할때와 동일한 경우)
하지만, getFree라는 정보가, 새어나가는 것을 원치 않는다.

### FACTORY 추가하기
1. `Policy`의 생성 책임을 `Moive`에서 `Client`로 옮겼다.
    - `Moive`는 특정 컨텍스트에 묶이면 안되기 때문
    - `Clien`t는 이제 `Moive`와 `Policy`를 생성한다.
1. `Client`도 특정 컨텍스트에 묶이지 않기를 희망한다.
    1. `Moive`를 생성을 `Client의 인스턴스`를 사용할 문맥을 결정할 `갑 클라인트`로 옮기자
    2. `Moive`의 생성과 관련된 지식이 `갑 클라이언트`로 새어나가길 희망하지 않는다.

객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가한다.
-> 이를 FACTORY 라고 부른다.

Client는 Movie를 생성하지 않는다.
생성의 주체와 사용의 주체가 분리가 되었다.

```Java
public class Factory {
	public Movie createAvatarMovie() {
		return new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000), new AmountDiscountPolicy(....));
	}
}

public class Client {
	private Factory factory;
	public Client(Factory factory) {
		this.factory = factory;
	}

	public Money getAvatarFee() {
		Movie avatar = factory.createAvatarMovie();
		return avatar.getFee();
	}
}
```

### 순수한 가공물에게 책임 할당
FACTORY는 순수한 기술적 결정
- 전체적으로 결합도를 낮추고 재사용을 높이기 위해, 객체 생성 책임을 도메인 개념과 아무런 상관이 없는 가공의 객체로 이동 시킨 것.

**표현적 분해**
- 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것.
- 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.

  모든 책임을 도메인에게 할당할 경우 아래의 심각한 문제를 야기
    - 낮은 응집도
    - 높은 결합도
    - 재사용 저하

  해결 방안: 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결한다.
    - **순수한 가공물**이라고 부른다.

어떠한 행동을 추가하고자 한다.
- 책임질 마땅한 마땅한 도메인 개념이 존재하지 않는다 -> 순수한 가공물을 추가하고 책임을 전가한다.
- **행위적 분해**에 의해 성생되는 것.

#### 객체지향이 실세계의 모방이라는 말은 옳지 않다.
도메인 개념뿐만 아니라 설계자들이 **임의적으로 창조한 인공적인 추상화들**을 포함하고 있다.
순수한 가공물들이 더 많은 비중을 차지하는 것이 일반적.

#### PURE FABRICATION 패턴
문제 도메인 개념을 표현하지 않는, 인위적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라.
이들 클래스는 문제 도메인 상에는 존재하지 않지만 순수하게 전체 설계의 품질을 높이기 위해 설계자의 임의에 따라 추가한 상상 속의 가공물이다.

## 03. [[의존성 주입]]

의존성을 해결하는 세가지의 방법.
1. 생성자 주입: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
2. setter 주입: 객체 생성 후 setter 메서드를 통한 의존성 해결
3. 메서드 주입: 메서드 실행 시 인자를 이용한 의존성 해결

Q. 생성자 주입 시, 객체의 생명주기에 대해서 설명하고 Spring에서 이야기하는 DI와 Bean들의 생명주기를 서술하시오.
A. 생성자 주입을 통해 설정된 인스턴스는 객체의 생명주기 전체에 걸쳐 관계를 유지한다.
Spring의 경우 Bean들은 Spring이 Bootup 될 시에 [[Spring IoC]] 컨테이너를 통해서 Bean을 등록하게 된다.
- 조사 중.

Setter 주입
장점
의존성의 대상을 런타임에 변경할 수 있다는 것.
단점
객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다.
객체가 생성된 후에 호출돼야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것이다.

메서드 호출 주입
의존성을 필요로하는 유일한 경우 때 사용할 수 있다.
의존성이 한 두 개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있다.

### 숨겨진 의존성은 나쁘다
**SERVICE LOCATOR 패턴**
- 의존성을 해결할 객체들을 보관하는 일종의 보관소
- 객체가 직접 `SERVICE LOCATOR`에게 의존성을 해결해줄 것을 요청

> SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다.

의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 `런타임`에 발견된다.
- 디버깅이 매우 어려워지는 요소

테스트 코드 작성이 어렵게 만든다.
- 테스트에 사용될 객체들이 모두 SERVICE LOCATOR와 연관을 갖게 되며, 각 테스트를 고립시킬 수 없는 상황도 발생시킨다.
- 각 테스트마다 SERVICE LOCATOR를 생성하고 제거하는 코드를 발생시킬 수 있다.

SERVICE LOCATOR는 캡슐화를 위반하는 결과를 초래한다.

## 04. 의존성 역전 원칙
### 추상화와 의존성 역전
객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다.
- `MOVIE`와 `AmountDiscountPolicy` 사이의 협력이 가지는 본질은 영화의 **가격을 계산**하는 것.
    - 어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다.

어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스다.

**추상화에 의존하라**
유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야한다.

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

### 의존성 역전 원칙과 패키지
**SEPARATED INTERFACE 패턴**
추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함을 시킨다.

![Pasted image 20231217104230.png](Pasted%20image%2020231217104230.png)

DiscountPolicy는 Movie 와 연관이 있다. Movie가 변경이 되었을 때 DiscountPolicy가 같이 배포가 이뤄져야한다.
문제는 DiscountPolicy가 별도의 패키지에 포함이 되어있다면 해당 패키지를 모두 컴파일을 해야하는 불필요한 비용이 발생한다.
또한 DiscountPolicy가 포함된 Amount DiscountPolicy가 변경이 되었다고 하더라도 Movie까지 모두 변경해서 배포를 해야한다.
그렇기에 위와 같은 모듈의 구조로 변경을 한다.

## 05. 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다
유연성은 복잡성을 수반한다.
- 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.
- 단순성과 명확성의 희생 위에서 자라난다.

불필요한 유연성은 불필요한 복장성을 낳는다.
- 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라.
- 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.
    - 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어라.

### 협력과 책임이 중요하다
역할, 책임, 협력에 초점을 맞춰야한다.

## 책을 읽고 난 후 떠오르는 생각들.
개방-폐쇄 원칙은 무엇인가?
- 개방-페쇄 원칙은 객체 간의 협력을 명확하게 하기 위해 생겨났다.
- 내가 알지 않아도 되는 부분들에 관해서는 철저히 몰라도 된다. 이는 곧 변경의 유연함으로 따라오게 되는 것으로 보인다.
    - 기존의 코드를 변경하지 않고, 확장할 수 있다는 점.

해당 원칙을 사용하면, 어떻게 유연한 설계가 이뤄질 수 있는가?
- 분업화를 통한 코드 작성이 충분히 가능해지는 것으로 고려된다.
- 유연한 설계라는 것은 서로 다른 도메인을 각 담당자가 최소한의 Interface만 정의를 후 통합하여 수행하였을 때 문제가 없다는 것을 의미하는 것으로 나는 생각한다.
- 그렇기에 개방-폐쇄 원칙을 활용한 설계를 하게 된다면, 철저하게 객체지향적인 개발이 가능할 것으로 고려된다.

해당 원칙을 사용한 코드의 예제는 어떻게 되는가?
- 추상화와 DI가 적극적으로 활용되기 시작한다.
- Spring의 Bean을 활용한 DI가 이를 활용한 예제로 보여진다.
    - Service 클래스는 Interface 혹은 추상화된 객체로 생성하게 된다.
    - 이를 구현한 Impl 객체들은 Contorller에 생성자 주입으로 연결 된다.
    - 외부로 드러난 Interface 만으로 통신을 하게 된다.
        - 이를 통하여 확장에 용이한가?
            - 확장에는 열려있지 않은 것으로 고려되긴 한다.
